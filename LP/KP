# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Гусева Софья Романовна

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |    24.04.22          |    3           |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

За время выполнения курсового проекта я изучила обширный пласт логического программирования, применила многие навыки, полученные при выполнении лабораторных работ: методы поиска и естественно-языковой интерфейс. Также я познакомилась с таким форматом как GedCom, который хорошо развит и документирован.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parents(потомок, отец, мать)
3. Реализовать предикат проверки/поиска vi. Теща
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве

## Получение родословного дерева

Моё родословное дерево получилось не сильно большим, поскольку найти сколько-нибудь достоверные данные было достать сложно. Моя семья разбросана по всей России и связи между родственниками поддерживаются плохо.

В моем родословном дереве 23 индивидуума.

## Конвертация родословного дерева

Для конвертации родословного дерева я использовал язык Python, поскольку он удобен для работы с текстом и идеально подходит для подобных задач -- быстро написать программу, который ты больше никогда не воспользуешься. Главным принципом моей программы является построчное считывание файла с запоминание id конкретного человека, затем по этим id создание семей. Генерация предиката child:

```
while (line[1] == 'CHIL'):
      if len(wife)>0 and len(husbando)>0:
        print("parents({0}, {1},{2}).".format(people[line[2]], husbando , wife))
      line = f.readline().split()
```

## Предикат поиска родственника

Предикат поиска родственника, в моём случае теща, реализован следующим образом:

```prolog
%% (Теща, мужчина)
motherInLaw(Z,X) :- parents(_,X,Y), parents(Y,_,Z), !.
```
Для начала ищем жену, а потом мать жены.

```prolog
?- motherInLaw(Z,"гусев Роман").
Z = "Самойлова Ирина".

?- motherInLaw(Z,"Самойлов Александр").
Z = "Сторожева Анастасия".
```

## Определение степени родства

```relative(Родство, X, Y)``` Кто Y для X? Определение родства двух конкретных индивидуумов.

При определении произвольной степени родства сперва проверяются тривиальные случаи, например

```prolog
relative(son, X, Y, _):-parents(Y,_,X), parents(_,Y,_),!.
```
когда все они пройдены, необходимо искать более сложные решения для это используется предикат

```prolog
relative(Surf-Deep, X, Y, N):-
	N = 'deep',
	relative(Deep, X, Intermediate, 'deep'),
	not(X = Intermediate),
	relative(Surf, Intermediate, Y, 'surface'),
	not(Y = Intermediate),
	not(X = Y).
 ```

Суть его заключается в следующем: определяем для Х человека, который является каким либо родственником ему, и пытаемся определить степень родства этого человека для Y. Чтобы избежать циклов и малочитаемых сложных решений на ранних стадиях поиска, поиск для Y осуществляется поверхностно, без захода в рекурсивную функцию опеределения родства. Полнота вывода от этого не страдает. Бесконечное количество ответов от такого решения оптимизации не уменьшилось. Однако удобочитаемость и простота ответов повысилась, поскольку подобный поиск очень похож на обход графа с итерационным спуском, величина спуска равна 1, таким спуском обусловливается последовательное увеличения количества слов в ответе.

## Выводы

Курсовой проект заставил меня задуматся над серьёзным изучением логических языков программирования.

Для начала было интересно разработать парсер на Python для родословного дерева, сперва я думала написать парсер на Прологе, но это оказалось неудобным, поэтому я использовала язык, который лучше подходит для данной задачи.

До этого момента естественный язык казался мне непостижимо сложным, неопределенным и творческим, таким, каким компьютер не сможет овладеть, хотя сейчас сопоставляя русский язык и абстракции в языках программирования, я подумал, что быть может вполне реально научить машину естественному языку, если она уже владеет такими сложными математическими концепциями и абстракциями.
